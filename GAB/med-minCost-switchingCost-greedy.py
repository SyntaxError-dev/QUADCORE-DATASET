# -*- coding: utf-8 -*-
"""med-minCost-switchingCost-greedy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cYVRVYGNPkhxNVcaR4uM3L6_x1oq-a77
"""

def minCost(n, arr):
    m = len(arr)

    # to store the frequency of each
    # task after the current position.
    freq = [[0] * (m + 1) for _ in range(m)]

    # to store the frequency from last
    freqArr = [0] * (m + 1)
    freq[m - 1] = freqArr[:]

    # fill the freq array from last to first
    for i in range(m - 2, -1, -1):

        # add the frequency of the next task
        freqArr[arr[i + 1]] += 1
        freq[i] = freqArr[:]

    # to store if task is running
    isRunning = [0] * (m + 1)

    # to store the total cost
    cost = 0

    # to store the count of occupied cores
    count = 0

    for i in range(m):

        # if task is already running,
        # continue to the next task
        if isRunning[arr[i]]:
            continue

        # if task is not running, and
        # there is a free core, use it
        # and increment the cost
        elif count < n:
            isRunning[arr[i]] = 1
            count += 1
            cost += 1

        # if all cores are occupied
        else:

            # check if there is a task that is
            # running and will not occur in future
            flag = False
            for j in range(1, m + 1):
                if isRunning[j] and freq[i][j] == 0:

                    # stop the task and start the
                    # current task in that core
                    isRunning[j] = 0
                    isRunning[arr[i]] = 1
                    cost += 1
                    flag = True
                    break

            # if there is no such task is found
            if not flag:

                # find the farthest position where one of
                # the currently running tasks will happen
                ind = m
                for j in range(m - 1, i, -1):
                    if isRunning[arr[j]]:
                        ind = j
                        break

                # stop that task and start the
                # current task in that core
                isRunning[arr[ind]] = 0
                isRunning[arr[i]] = 1
                cost += 1

    return cost

if __name__ == "__main__":
    arr = [1, 2, 1, 3, 4, 1]
    n = 3
    print(minCost(n, arr))