# -*- coding: utf-8 -*-
"""TestingGround

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qAK55MRYryFiBNiJa5e_feUPqSpswMog
"""

"""
A Hamiltonian cycle visits each node exactly once.
This implementation uses backtracking to find a valid cycle in a graph.
"""

def valid_connection(graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]) -> bool:
    # 1. Validate that path exists between current and next vertices
    if graph[path[curr_ind - 1]][next_ver] == 0:
        return False

    # 2. Validate that next vertex is not already in path
    return not any(vertex == next_ver for vertex in path)

def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:
    # Base Case: All vertices visited
    if curr_ind == len(graph):
        # Return whether path exists between last visited and starting vertex
        return graph[path[curr_ind - 1]][path[0]] == 1

    # Recursive Step
    for next_ver in range(len(graph)):
        if valid_connection(graph, next_ver, curr_ind, path):
            path[curr_ind] = next_ver
            if util_hamilton_cycle(graph, path, curr_ind + 1):
                return True
            # Backtrack
            path[curr_ind] = -1
    return False

def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:
    path = [-1] * (len(graph) + 1)
    path[0] = path[-1] = start_index
    return path if util_hamilton_cycle(graph, path, 1) else []

# DRIVER CODE: Ensures the script runs and ends by itself
if __name__ == "__main__":
    # Example graph represented as an adjacency matrix
    example_graph = [
        [0, 1, 0, 1, 0],
        [1, 0, 1, 1, 1],
        [0, 1, 0, 0, 1],
        [1, 1, 0, 0, 1],
        [0, 1, 1, 1, 0]
    ]

    # Solve starting from vertex 0
    result = hamilton_cycle(example_graph, 0)

    if result:
        print(f"Hamiltonian Cycle found: {result}")
    else:
        print("No Hamiltonian Cycle exists for this graph.")